<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V1 Repricing Algorithm - Technical Documentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 0;
            min-height: 100vh;
        }

        /* Sidebar Navigation */
        .sidebar {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
        }

        .sidebar h2 {
            color: #3498db;
            margin-bottom: 20px;
            font-size: 1.3rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .sidebar nav ul {
            list-style: none;
        }

        .sidebar nav ul li {
            margin-bottom: 8px;
        }

        .sidebar nav ul li a {
            color: #ecf0f1;
            text-decoration: none;
            display: block;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .sidebar nav ul li a:hover {
            background: #34495e;
            color: #3498db;
            padding-left: 18px;
        }

        .sidebar nav ul ul {
            margin-left: 15px;
            margin-top: 5px;
        }

        .sidebar nav ul ul li a {
            font-size: 0.85rem;
            color: #bdc3c7;
        }

        /* Main Content */
        .content {
            background: white;
            padding: 40px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
        }

        header {
            border-bottom: 3px solid #3498db;
            padding-bottom: 20px;
            margin-bottom: 40px;
        }

        h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        h2 {
            color: #2c3e50;
            font-size: 2rem;
            margin-top: 50px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        h3 {
            color: #34495e;
            font-size: 1.5rem;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        h4 {
            color: #7f8c8d;
            font-size: 1.2rem;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            color: #555;
        }

        /* Code Blocks */
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
        }

        .inline-code {
            background: #ecf0f1;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            color: #e74c3c;
            font-size: 0.9rem;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        th {
            background: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
        }

        tr:hover {
            background: #f8f9fa;
        }

        /* Boxes and Alerts */
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .success-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .error-box {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        /* Process Flow */
        .flow-diagram {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
        }

        .flow-step {
            margin: 10px 0;
            padding-left: 20px;
        }

        .flow-step::before {
            content: "‚Üí";
            margin-right: 10px;
            color: #3498db;
            font-weight: bold;
        }

        /* Function Signatures */
        .function-signature {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #e74c3c;
        }

        .param-list {
            list-style: none;
            margin: 10px 0;
        }

        .param-list li {
            padding: 8px 0;
            border-bottom: 1px solid #ecf0f1;
        }

        .param-name {
            color: #3498db;
            font-weight: bold;
        }

        .param-type {
            color: #e67e22;
            font-style: italic;
        }

        /* File Structure */
        .file-tree {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            font-family: monospace;
            margin: 20px 0;
        }

        .file-tree ul {
            list-style: none;
            padding-left: 20px;
        }

        .file-tree li {
            margin: 5px 0;
        }

        .file-tree .file::before {
            content: "üìÑ ";
        }

        .file-tree .folder::before {
            content: "üìÅ ";
        }

        /* Tags and Badges */
        .tag {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            margin: 2px;
        }

        .tag-primary { background: #3498db; color: white; }
        .tag-success { background: #27ae60; color: white; }
        .tag-warning { background: #f39c12; color: white; }
        .tag-danger { background: #e74c3c; color: white; }
        .tag-info { background: #16a085; color: white; }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Print Styles */
        @media print {
            .sidebar {
                display: none;
            }
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar Navigation -->
        <aside class="sidebar">
            <h2>Navigation</h2>
            <nav>
                <ul>
                    <li><a href="#overview">Algorithm Overview</a></li>
                    <li><a href="#file-structure">File Structure</a></li>
                    <li><a href="#workflow">Step-by-Step Process</a></li>
                    <li><a href="#main-function">Main Function</a>
                        <ul>
                            <li><a href="#reprice-product">repriceProduct()</a></li>
                            <li><a href="#reprice-to-max">repriceProductToMax()</a></li>
                        </ul>
                    </li>
                    <li><a href="#core-logic">Core Repricing Logic</a>
                        <ul>
                            <li><a href="#standard-reprice">Standard Reprice</a></li>
                            <li><a href="#nc-reprice">NC Reprice (w/ Shipping)</a></li>
                            <li><a href="#multi-price">Multi-Price Breaks</a></li>
                        </ul>
                    </li>
                    <li><a href="#rules">Business Rules</a>
                        <ul>
                            <li><a href="#pricing-rules">Pricing Direction Rules</a></li>
                            <li><a href="#floor-ceiling">Floor & Ceiling</a></li>
                            <li><a href="#special-rules">Special Rules</a></li>
                        </ul>
                    </li>
                    <li><a href="#functions">Function Catalog</a></li>
                    <li><a href="#data-flow">Data Flow</a></li>
                    <li><a href="#edge-cases">Edge Cases</a></li>
                    <li><a href="#integration">Integration Points</a></li>
                </ul>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="content">
            <header>
                <h1>V1 Repricing Algorithm</h1>
                <p class="subtitle">Comprehensive Technical Documentation</p>
                <div style="margin-top: 15px;">
                    <span class="tag tag-primary">Version 1</span>
                    <span class="tag tag-info">TypeScript</span>
                    <span class="tag tag-success">Production</span>
                </div>
            </header>

            <!-- ========== OVERVIEW ========== -->
            <section id="overview">
                <h2>1. Algorithm Overview</h2>

                <div class="info-box">
                    <strong>Purpose:</strong> The V1 Repricing Algorithm is a competitive pricing engine that automatically adjusts product prices based on competitor pricing data, business rules, and configured constraints.
                </div>

                <h3>High-Level Workflow</h3>
                <div class="flow-diagram">
                    <div class="flow-step">Input: Product data + Competitor prices from Net32 API</div>
                    <div class="flow-step">Format and validate API response</div>
                    <div class="flow-step">Filter active competitors and apply threshold logic</div>
                    <div class="flow-step">Execute repricing logic (Standard or NC mode)</div>
                    <div class="flow-step">Apply business rules (floor, ceiling, direction)</div>
                    <div class="flow-step">Apply special rules (badges, buy box, sister vendors)</div>
                    <div class="flow-step">Validate multi-price break logic</div>
                    <div class="flow-step">Record history and update database</div>
                    <div class="flow-step">Execute price update via vendor API</div>
                    <div class="flow-step">Output: Updated pricing + execution report</div>
                </div>

                <h3>Core Capabilities</h3>
                <ul>
                    <li><strong>Competitive Analysis:</strong> Identifies lowest competitor prices and calculates optimal positioning</li>
                    <li><strong>Multi-Price Break Support:</strong> Handles quantity-based pricing tiers (Q1, Q2, Q3, etc.)</li>
                    <li><strong>Business Rules Engine:</strong> Enforces directional rules (Up Only, Down Only, Both), floor/ceiling prices</li>
                    <li><strong>NC Mode:</strong> Includes shipping costs in price comparisons for accurate total cost analysis</li>
                    <li><strong>Badge Logic:</strong> Applies special pricing for products with promotional badges</li>
                    <li><strong>Buy Box Strategy:</strong> Optimizes pricing to win marketplace buy box placement</li>
                    <li><strong>Sister Vendor Filtering:</strong> Excludes related vendors from competition when configured</li>
                </ul>

                <h3>Key Statistics</h3>
                <table>
                    <tr>
                        <th>Metric</th>
                        <th>Value</th>
                    </tr>
                    <tr>
                        <td>Total Lines of Code</td>
                        <td>5,103 lines</td>
                    </tr>
                    <tr>
                        <td>Number of Files</td>
                        <td>5 core files</td>
                    </tr>
                    <tr>
                        <td>Business Rules</td>
                        <td>15+ configurable rules</td>
                    </tr>
                    <tr>
                        <td>Price Break Support</td>
                        <td>Unlimited quantity tiers</td>
                    </tr>
                </table>
            </section>

            <!-- ========== FILE STRUCTURE ========== -->
            <section id="file-structure">
                <h2>2. File Structure</h2>

                <div class="file-tree">
                    <ul>
                        <li class="folder">apps/api-core/src/utility/reprice-algo/v1/
                            <ul>
                                <li class="file">algo-v1.ts (765 lines) - Main orchestration</li>
                                <li class="file">reprice-helper.ts (1,529 lines) - Standard repricing logic</li>
                                <li class="file">reprice-helper-nc.ts (1,722 lines) - NC (shipping-inclusive) repricing</li>
                                <li class="file">repricer-rule-helper.ts (951 lines) - Business rules engine</li>
                                <li class="file">shared.ts (136 lines) - Shared utilities</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <h3>File Responsibilities</h3>

                <h4>algo-v1.ts</h4>
                <p>The main orchestration file that coordinates the entire repricing workflow.</p>
                <ul>
                    <li><strong>Main Functions:</strong> <code>repriceProduct()</code>, <code>repriceProductToMax()</code></li>
                    <li><strong>Responsibilities:</strong>
                        <ul>
                            <li>API response formatting and validation</li>
                            <li>Own vendor threshold logic</li>
                            <li>Multi-price break coordination</li>
                            <li>Rule application sequencing</li>
                            <li>History recording and status updates</li>
                            <li>Price update API calls</li>
                        </ul>
                    </li>
                    <li><strong>Dependencies:</strong> All other V1 files, format-wrapper, history-helper, mysql-helper</li>
                </ul>

                <h4>reprice-helper.ts</h4>
                <p>Standard repricing logic that competes based on product price alone (without shipping).</p>
                <ul>
                    <li><strong>Main Functions:</strong> <code>Reprice()</code>, <code>RepriceIndividualPriceBreak()</code>, <code>RepriceToMax()</code></li>
                    <li><strong>Responsibilities:</strong>
                        <ul>
                            <li>Competitor filtering and sorting</li>
                            <li>Price positioning calculation</li>
                            <li>Floor/ceiling enforcement</li>
                            <li>Sister vendor logic</li>
                            <li>Tie scenario handling</li>
                        </ul>
                    </li>
                    <li><strong>Price Calculation:</strong> Based on unit price only</li>
                </ul>

                <h4>reprice-helper-nc.ts</h4>
                <p>NC (Non-Compete) repricing logic that includes shipping costs in price comparisons.</p>
                <ul>
                    <li><strong>Main Functions:</strong> <code>Reprice()</code>, <code>RepriceIndividualPriceBreak()</code></li>
                    <li><strong>Responsibilities:</strong>
                        <ul>
                            <li>Same as reprice-helper.ts but with shipping inclusion</li>
                            <li>Total cost calculation (unit price + shipping)</li>
                            <li>Shipping threshold logic</li>
                        </ul>
                    </li>
                    <li><strong>Price Calculation:</strong> Based on unit price + shipping cost</li>
                </ul>

                <h4>repricer-rule-helper.ts</h4>
                <p>Business rules engine that applies pricing constraints and special logic.</p>
                <ul>
                    <li><strong>Main Functions:</strong> 15+ rule application functions</li>
                    <li><strong>Responsibilities:</strong>
                        <ul>
                            <li>Directional rules (Up Only, Down Only, Both)</li>
                            <li>Multi-price break validation</li>
                            <li>Floor and ceiling checks</li>
                            <li>Badge percentage logic</li>
                            <li>Buy box rules</li>
                            <li>Sister comparison checks</li>
                            <li>Keep position logic</li>
                        </ul>
                    </li>
                </ul>

                <h4>shared.ts</h4>
                <p>Shared utility functions used across the algorithm.</p>
                <ul>
                    <li><strong>Functions:</strong> Price validation, floor detection, secret key retrieval, override checks</li>
                    <li><strong>Responsibilities:</strong>
                        <ul>
                            <li>Price update requirement detection</li>
                            <li>Floor reached detection</li>
                            <li>Price step calculation ($UP/$DOWN)</li>
                            <li>Configuration retrieval</li>
                        </ul>
                    </li>
                </ul>
            </section>

            <!-- ========== WORKFLOW ========== -->
            <section id="workflow">
                <h2>3. Step-by-Step Process</h2>

                <p>The V1 algorithm follows a sequential 15-step process to determine optimal pricing:</p>

                <h3>Step 1: Input Validation & Formatting</h3>
                <div class="flow-diagram">
                    <div class="flow-step">Receive Net32 product data array</div>
                    <div class="flow-step">Validate response is not empty</div>
                    <div class="flow-step">Format active field (normalize boolean values)</div>
                    <div class="flow-step">Format shipping threshold data</div>
                    <div class="flow-step">Set global vendor details from context</div>
                </div>
                <div class="warning-box">
                    <strong>Error Handling:</strong> Throws "Invalid response found in Net32 Api" if result is empty or null.
                </div>

                <h3>Step 2: Own Vendor Threshold Logic</h3>
                <pre><code>// Apply own vendor threshold to filter out own products at different price points
result = await formatter.SetOwnVendorThreshold(productItem, result);</code></pre>
                <p>This step ensures that the vendor's own products are correctly identified and can be excluded from competitive comparison when configured.</p>

                <h3>Step 3: Own Product Identification</h3>
                <pre><code>let ownProduct = await responseUtility.GetOwnProduct(result, productItem);
let output = responseUtility.FilterActiveResponse(result, productItem);</code></pre>
                <div class="info-box">
                    If own product is not found in the response, the algorithm returns with message: <code>IGNORE_NOT_FOUND_API</code>
                </div>

                <h3>Step 4: Multi-Price Break Enhancement</h3>
                <pre><code>if (flagMultiPriceUpdate === true) {
    const distinctPriceBreaks = await repriceHelper.GetDistinctPriceBreaksAcrossVendors(
        output, ownProduct, productItem
    );
    // Add distinct price breaks from competitors to own product
}</code></pre>
                <p>Identifies unique price break quantities across all vendors and adds them to the own product for competitive analysis.</p>

                <h3>Step 5: Q2 Price Break Validation</h3>
                <pre><code>const isMinQty2PriceBreakExists = MinQtyPricePresent(ownProduct.priceBreaks, 2);

if (productItem.compareWithQ1 && !isMinQty2PriceBreakExists) {
    ownProduct.priceBreaks.push({
        minQty: 2,
        unitPrice: 0,
        active: true
    });
}</code></pre>
                <p>Ensures Q2 (quantity 2) price point exists when configured for Q1 comparison.</p>

                <h3>Step 6: Stock Validation & Mode Selection</h3>
                <pre><code>if (productItem && ownProduct && ownProduct.inStock) {
    if (productItem.is_nc_needed) {
        // Execute NC reprice (with shipping)
        repriceResult = await repriceHelperNc.Reprice(...)
    } else {
        // Execute standard reprice
        repriceResult = await repriceHelper.Reprice(...)
    }
}</code></pre>
                <p>Routes to appropriate repricing mode based on configuration:</p>
                <ul>
                    <li><strong>NC Mode:</strong> Includes shipping in price calculations</li>
                    <li><strong>Standard Mode:</strong> Price-only comparison</li>
                </ul>

                <h3>Step 7: Multi-Price Break Processing</h3>
                <pre><code>if (ownProduct.priceBreaks && ownProduct.priceBreaks.length > 1) {
    for (const priceBreak of ownProduct.priceBreaks) {
        // Get competitors at same quantity level
        const otherVendorRepriceDetails = await getSamePriceBreakDetails(
            output, priceBreak, productItem
        );

        // Reprice individual price break
        indRepriceResult = await repriceHelper.RepriceIndividualPriceBreak(...)

        // Handle deactivation for price breaks with no competition
        if (otherVendorRepriceDetails.length === 0 && priceBreak.minQty !== 1) {
            indRepriceResult.togglePricePoint(false);
        }
    }
}</code></pre>

                <h3>Step 8: NC Buy Box Override</h3>
                <pre><code>if (productItem.applyNcForBuyBox) {
    for (const $eval of repriceResult.listOfRepriceDetails) {
        const isFloorReached = await getIsFloorReached($eval);
        if (isFloorReached) {
            // Override with NC logic to win buy box
            overridingRepriceResult = await repriceHelperNc.RepriceIndividualPriceBreak(...)
        }
    }
}</code></pre>
                <p>When floor price is reached, switches to NC mode to calculate if buy box can be won with shipping advantage.</p>

                <h3>Step 9: Repricing Rule Application</h3>
                <pre><code>const isOverrideEnabled = await isOverrideEnabledForProduct(
    productItem.override_bulk_update
);

if (productItem.repricingRule != null && !isOverrideEnabled) {
    repriceResult = await Rule.ApplyRule(
        repriceResult,
        productItem.repricingRule,
        isNcToBeApplied,
        ownProduct
    );
}</code></pre>
                <p>Applies configured repricing rule:</p>
                <ul>
                    <li><code>0</code>: Only Up - Prevents price decreases</li>
                    <li><code>1</code>: Only Down - Prevents price increases</li>
                    <li><code>2</code>: Both - Allows any price change</li>
                </ul>

                <h3>Step 10-14: Additional Business Rules</h3>
                <div class="flow-diagram">
                    <div class="flow-step"><strong>Step 10:</strong> Deactivate Q Price Break Rule</div>
                    <div class="flow-step"><strong>Step 11:</strong> Multi-Price Break Validation</div>
                    <div class="flow-step"><strong>Step 12:</strong> Beat Q Price Rule (ignores Q1 changes)</div>
                    <div class="flow-step"><strong>Step 13:</strong> Percentage Increase Limit</div>
                    <div class="flow-step"><strong>Step 14:</strong> Buy Box Logic</div>
                </div>

                <h3>Step 15: Final Validation & Execution</h3>
                <div class="flow-diagram">
                    <div class="flow-step">Apply Keep Position Logic</div>
                    <div class="flow-step">Suppress Price Break for One (if configured)</div>
                    <div class="flow-step">Apply Floor Check Rule</div>
                    <div class="flow-step">Apply Badge Percentage Down Rule</div>
                    <div class="flow-step">Final Multi-Price Break Validation</div>
                    <div class="flow-step">Append #NEW tag for new price break activations</div>
                    <div class="flow-step">Apply Shipping & Badge Buy Box Rules</div>
                    <div class="flow-step">Sister Comparison Check</div>
                    <div class="flow-step">Align IsRepriced field</div>
                    <div class="flow-step">Update triggered vendor</div>
                    <div class="flow-step">Execute history recording</div>
                    <div class="flow-step">Update reprice result status</div>
                    <div class="flow-step">Execute price update API call (if needed)</div>
                </div>
            </section>

            <!-- ========== MAIN FUNCTION ========== -->
            <section id="main-function">
                <h2>4. Main Function: repriceProduct()</h2>

                <div class="function-signature">
<code>export async function repriceProduct(
    mpid: string,
    net32Products: Net32Product[],
    internalProduct: FrontierProduct,
    contextVendor: string
): Promise&lt;{
    cronResponse: RepriceAsyncResponse;
    priceUpdateResponse: any;
    historyIdentifier: string | null;
}&gt;</code>
                </div>

                <h3>Parameters</h3>
                <ul class="param-list">
                    <li>
                        <span class="param-name">mpid</span>
                        <span class="param-type">string</span>
                        <p>Marketplace Product ID - unique identifier for the product</p>
                    </li>
                    <li>
                        <span class="param-name">net32Products</span>
                        <span class="param-type">Net32Product[]</span>
                        <p>Array of competitor product data from Net32 API including prices, vendors, and availability</p>
                    </li>
                    <li>
                        <span class="param-name">internalProduct</span>
                        <span class="param-type">FrontierProduct</span>
                        <p>Internal product configuration including pricing rules, floor/ceiling, and settings</p>
                    </li>
                    <li>
                        <span class="param-name">contextVendor</span>
                        <span class="param-type">string</span>
                        <p>Vendor context identifier (e.g., "NET32", "DARBY") for execution tracking</p>
                    </li>
                </ul>

                <h3>Return Value</h3>
                <pre><code>{
    cronResponse: RepriceAsyncResponse {
        repriceData: RepriceModel,      // Calculated pricing and decisions
        scrapedData: Net32Product[]     // Competitor data (if scrapeOn enabled)
    },
    priceUpdateResponse: {              // API response from price update
        status: string,
        message?: string
    } | null,
    historyIdentifier: string | null    // Database ID for history record
}</code></pre>

                <h3>Execution Flow</h3>
                <ol>
                    <li>Validate and format input data</li>
                    <li>Identify own product in competition</li>
                    <li>Execute appropriate reprice mode (Standard/NC, Single/Multi price break)</li>
                    <li>Apply all configured business rules in sequence</li>
                    <li>Record history and update database</li>
                    <li>Execute price update if needed and not in "waiting" state</li>
                    <li>Return comprehensive result object</li>
                </ol>

                <div class="warning-box">
                    <strong>Important:</strong> Price updates only execute if:
                    <ul>
                        <li>Product is not in "waiting for next run" state</li>
                        <li>Algorithm execution mode is V1_ONLY or V1_EXECUTE_V2_DRY</li>
                        <li>Environment is not DEV (or DEV mode allows updates)</li>
                        <li>Calculated price differs from current price</li>
                    </ul>
                </div>
            </section>

            <section id="reprice-to-max">
                <h3>Alternative Function: repriceProductToMax()</h3>

                <div class="function-signature">
<code>export async function repriceProductToMax(
    mpid: string,
    net32Products: Net32Product[],
    internalProduct: FrontierProduct,
    contextVendor: string
)</code>
                </div>

                <p>Simplified repricing function that sets price to maximum configured value.</p>

                <h4>Key Differences from repriceProduct():</h4>
                <ul>
                    <li>Only executes <code>RepriceToMax()</code> logic</li>
                    <li>Bypasses all business rules except basic validation</li>
                    <li>Only handles single price break (minQty=1)</li>
                    <li>Used for emergency price maximization scenarios</li>
                </ul>

                <div class="info-box">
                    <strong>Use Case:</strong> This function is typically used when rapidly pulling back from competitive pricing to maximize margins during market uncertainty or inventory shortages.
                </div>
            </section>

            <!-- ========== CORE LOGIC ========== -->
            <section id="core-logic">
                <h2>5. Core Repricing Logic</h2>

                <h3 id="standard-reprice">Standard Reprice Mode</h3>
                <p>Located in <code>reprice-helper.ts</code>, this mode competes based on unit price alone.</p>

                <h4>Competitor Filtering Process</h4>
                <div class="flow-diagram">
                    <div class="flow-step">Extract products with active minQty=1 price break</div>
                    <div class="flow-step">Filter by excluded vendors (sister companies)</div>
                    <div class="flow-step">Filter by inventory threshold (min stock levels)</div>
                    <div class="flow-step">Filter by handling time constraints</div>
                    <div class="flow-step">Filter by badge indicators</div>
                    <div class="flow-step">Remove duplicate price points</div>
                    <div class="flow-step">Sort by unit price ascending</div>
                </div>

                <h4>Price Calculation Logic</h4>
                <pre><code>// Calculate context price with offset
const contextPriceResult = await filterMapper.GetContextPrice(
    parseFloat(lowestPrice),
    processOffset,        // Typically 0.01 to undercut by 1 cent
    floorPrice,
    parseFloat(productItem.percentageDown),
    minQty
);

const contextPrice = contextPriceResult.Price;

// Determine new price
if (lowestPrice > contextPrice && contextPrice <= maxPrice) {
    newPrice = contextPrice;  // Undercut competitor
} else if (lowestPrice > maxPrice) {
    newPrice = maxPrice;      // Hit ceiling
} else {
    // No change needed or floor reached
}</code></pre>

                <h4>Scenario Handling</h4>
                <table>
                    <tr>
                        <th>Scenario</th>
                        <th>Action</th>
                        <th>Message</th>
                    </tr>
                    <tr>
                        <td>Own vendor is lowest</td>
                        <td>Price up to next competitor or max</td>
                        <td>PRICE_UP_NEXT, PRICE_MAXED</td>
                    </tr>
                    <tr>
                        <td>Competitor is lowest</td>
                        <td>Undercut by offset amount</td>
                        <td>PRICE_DOWN_OFFSET</td>
                    </tr>
                    <tr>
                        <td>No competitors</td>
                        <td>Set to max price</td>
                        <td>NO_COMPETITOR</td>
                    </tr>
                    <tr>
                        <td>Sister vendor lowest</td>
                        <td>No change (or compete if configured)</td>
                        <td>NO_COMPETITOR_SISTER_VENDOR</td>
                    </tr>
                    <tr>
                        <td>Floor price reached</td>
                        <td>Stop at floor</td>
                        <td>IGNORED_FLOOR_REACHED</td>
                    </tr>
                    <tr>
                        <td>Tie scenario</td>
                        <td>Check if tie with sister</td>
                        <td>Context-dependent</td>
                    </tr>
                </table>

                <h3 id="nc-reprice">NC Reprice Mode (with Shipping)</h3>
                <p>Located in <code>reprice-helper-nc.ts</code>, this mode includes shipping costs for total cost comparison.</p>

                <h4>Key Differences</h4>
                <ul>
                    <li><strong>Price Calculation:</strong> <code>unitPrice + shippingCost</code> instead of just <code>unitPrice</code></li>
                    <li><strong>Sorting:</strong> Sorts competitors by total cost (price + shipping)</li>
                    <li><strong>Comparison:</strong> Competes based on total delivered cost to customer</li>
                    <li><strong>Output:</strong> Still outputs unit price (shipping handled separately in UI)</li>
                </ul>

                <pre><code>// NC Mode shipping calculation
const GetShippingPrice = (product: Net32Product) => {
    return product.shipping?.standardShipping || 0;
}

// Sort by total cost
let sortedPayload = _.sortBy(tempEligibleList, [
    (prod) => {
        return (
            _.find(prod.priceBreaks, (x) => x.minQty == 1 && x.active == true).unitPrice
            + GetShippingPrice(prod)
        );
    }
]);</code></pre>

                <div class="success-box">
                    <strong>Business Value:</strong> NC mode ensures accurate competitive positioning when shipping costs vary significantly between vendors, preventing margin erosion from hidden shipping advantages.
                </div>

                <h3 id="multi-price">Multi-Price Break Logic</h3>
                <p>When a product has multiple quantity tiers (Q1, Q2, Q3, Q6, etc.), each tier is repriced independently.</p>

                <h4>Process for Each Price Break</h4>
                <pre><code>for (const priceBreak of ownProduct.priceBreaks) {
    // Get competitors at same quantity level
    const otherVendorRepriceDetails = await getSamePriceBreakDetails(
        output, priceBreak, productItem
    );

    // Reprice this specific quantity tier
    indRepriceResult = await repriceHelper.RepriceIndividualPriceBreak(
        ownProduct, output, productItem, mpid, priceBreak
    );

    // If no competition at this tier (except Q1), deactivate it
    if (otherVendorRepriceDetails.length === 0 && priceBreak.minQty !== 1) {
        indRepriceResult.togglePricePoint(false);
        indRepriceResult.togglePriceUpdation(true);
    }

    multipleRepriceData.listOfRepriceDetails.push(indRepriceResult.repriceDetails);
}</code></pre>

                <h4>Multi-Price Validation Rules</h4>
                <ol>
                    <li><strong>Descending Price Rule:</strong> Higher quantities must have lower or equal unit prices</li>
                    <li><strong>No Competition Deactivation:</strong> Price breaks with no competition are deactivated (except Q1)</li>
                    <li><strong>Q1 Comparison:</strong> When <code>compareWithQ1</code> is enabled, Q2 competes with Q1 prices</li>
                    <li><strong>Floor Enforcement:</strong> Each price break respects global floor price independently</li>
                </ol>

                <div class="warning-box">
                    <strong>Critical Rule:</strong> The algorithm runs <code>ApplyMultiPriceBreakRule()</code> multiple times to ensure price break consistency after each rule application. This prevents scenarios where Q3 price is higher than Q2.
                </div>
            </section>

            <!-- ========== RULES ========== -->
            <section id="rules">
                <h2>6. Business Rules Engine</h2>

                <p>The rules engine in <code>repricer-rule-helper.ts</code> applies business logic and constraints to calculated prices.</p>

                <h3 id="pricing-rules">Pricing Direction Rules</h3>

                <h4>ApplyRule(repriceResult, ruleIdentifier, isNcNeeded, net32Details)</h4>

                <table>
                    <tr>
                        <th>Rule ID</th>
                        <th>Name</th>
                        <th>Logic</th>
                        <th>Message</th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>Only Up</td>
                        <td>If newPrice &lt; oldPrice ‚Üí reject change</td>
                        <td>IGNORED_PRODUCT_SETTING_RULE_ONLY_UP</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>Only Down</td>
                        <td>If newPrice &gt; oldPrice ‚Üí reject change</td>
                        <td>IGNORED_PRODUCT_SETTING_RULE_ONLY_DOWN</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Both</td>
                        <td>Allow any direction</td>
                        <td>No message added</td>
                    </tr>
                    <tr>
                        <td>-1</td>
                        <td>Please Select</td>
                        <td>No action (default)</td>
                        <td>N/A</td>
                    </tr>
                </table>

                <pre><code>// Only Up Rule Example
case 0:
    if (parseFloat($.newPrice) < calculatedOldPrice) {
        $.goToPrice = $.newPrice;         // Store rejected price
        $.newPrice = "N/A";               // Cancel price change
        $.isRepriced = false;             // Mark as not repriced
        $.explained = IGNORED_PRODUCT_SETTING_RULE_ONLY_UP;
    }
    break;</code></pre>

                <h3 id="floor-ceiling">Floor & Ceiling Enforcement</h3>

                <h4>ApplyFloorCheckRule(repriceResult, floorPrice)</h4>
                <p>Ensures no price falls below configured floor price.</p>

                <pre><code>if ($.newPrice !== "N/A" && parseFloat($.newPrice) < floorPrice) {
    if (floorPrice !== $.oldPrice) {
        $.newPrice = floorPrice;
        $.explained = PRICE_FLOORED;
        $.isRepriced = true;
    } else {
        $.newPrice = "N/A";
        $.explained = IGNORED_FLOOR_REACHED;
        $.isRepriced = false;
    }
}</code></pre>

                <div class="info-box">
                    <strong>Floor Logic:</strong> If calculated price is below floor, set to floor price. If already at floor, no change (marked as #HITFLOOR).
                </div>

                <h4>Ceiling (Max Price) Enforcement</h4>
                <p>Handled in core reprice logic, not as separate rule:</p>
                <pre><code>if (contextPrice > maxPrice) {
    newPrice = maxPrice;
    message = PRICE_MAXED_MANUAL;
}</code></pre>

                <h3 id="special-rules">Special Business Rules</h3>

                <h4>1. ApplyMultiPriceBreakRule()</h4>
                <p>Validates price break hierarchy and deactivates invalid tiers.</p>

                <pre><code>// Ensure Q3 price ‚â§ Q2 price ‚â§ Q1 price
for (let idx = repriceResult.listOfRepriceDetails.length - 1; idx >= 0; idx--) {
    const sourcePrice = repriceResult.listOfRepriceDetails[idx].newPrice !== "N/A"
        ? parseFloat(repriceResult.listOfRepriceDetails[idx].newPrice)
        : repriceResult.listOfRepriceDetails[idx].oldPrice;

    let success = true;
    // Check against all lower quantity tiers
    for (let k = 0; k < idx; k++) {
        const comparablePrice = repriceResult.listOfRepriceDetails[k].newPrice !== "N/A"
            ? parseFloat(repriceResult.listOfRepriceDetails[k].newPrice)
            : repriceResult.listOfRepriceDetails[k].oldPrice;

        if (sourcePrice >= comparablePrice && comparablePrice !== 0) {
            success = false;  // Price break violates hierarchy
        }
    }

    if (!success) {
        // Deactivate or mark as invalid
        dummyPricePoint.newPrice = 0;
        dummyPricePoint.active = false;
        dummyPricePoint.explained += "_SHUT_DOWN_FLOOR_REACHED";
    }
}</code></pre>

                <h4>2. ApplyBeatQPriceRule()</h4>
                <p>Prevents changes to Q1 pricing when configured.</p>
                <pre><code>$eval.listOfRepriceDetails.forEach(($) => {
    if ($.minQty == 1) {
        $.goToPrice = $.newPrice;
        $.newPrice = "N/A";
        $.isRepriced = false;
        $.explained = BEAT_Q_PRICE;  // Ignore Q1 changes
    }
});</code></pre>

                <h4>3. ApplyPercentagePriceRule(percentage)</h4>
                <p>Limits price increases to configured percentage.</p>
                <pre><code>if (parseFloat($.newPrice) > $.oldPrice) {
    const percentageIncrease = ((parseFloat($.newPrice) - $.oldPrice) / $.oldPrice) * 100;

    if (percentageIncrease > percentage) {
        $.goToPrice = $.newPrice;
        $.newPrice = "N/A";
        $.isRepriced = false;
        $.explained = IGNORED_PERCENTAGE_CHECK;
    }
}</code></pre>

                <h4>4. ApplyBuyBoxRule(repriceResult, net32Result)</h4>
                <p>Prevents price decreases when own vendor has buy box.</p>
                <pre><code>const contextVendorIds = ["17357", "20722", "20755", "20533", "20727", "5"];
const firstItem = _.first(net32Result);

if (parseFloat($.newPrice) < $.oldPrice) {
    if (firstItem && _.includes(contextVendorIds, firstItem.vendorId.toString())) {
        $.newPrice = "N/A";           // Keep current price
        $.explained = IGNORE_BUY_BOX; // Already have buy box
    }
}</code></pre>

                <h4>5. ApplyKeepPositionLogic(repriceResult, result, ownVendorId)</h4>
                <p>Maintains current competitive position if already optimal.</p>

                <h4>6. ApplySuppressPriceBreakRule(repriceResult, minQty, isOverrideEnabled)</h4>
                <p>When enabled, only allows changes to Q1 price break.</p>

                <h4>7. ApplyDeactivateQPriceBreakRule(repriceResult, abortDeactivatingQPriceBreak)</h4>
                <p>Prevents automatic deactivation of quantity price breaks when configured.</p>

                <h4>8. ApplyRepriceDownBadgeCheckRule(repriceResult, result, productItem, badgePercentageDown)</h4>
                <p>Applies special percentage down limit for badge products.</p>

                <h4>9. ApplySisterComparisonCheck(repriceResult, result, productItem)</h4>
                <p>Final validation that sister vendors are not triggering price changes when prohibited.</p>

                <h4>10. AppendNewPriceBreakActivation(repriceResult)</h4>
                <p>Adds #NEW tag to newly activated price breaks for reporting clarity.</p>
            </section>

            <!-- ========== FUNCTIONS ========== -->
            <section id="functions">
                <h2>7. Function Catalog</h2>

                <h3>algo-v1.ts Functions</h3>

                <table>
                    <tr>
                        <th>Function</th>
                        <th>Purpose</th>
                        <th>Returns</th>
                    </tr>
                    <tr>
                        <td><code>repriceProduct()</code></td>
                        <td>Main repricing orchestration with full rule application</td>
                        <td>{ cronResponse, priceUpdateResponse, historyIdentifier }</td>
                    </tr>
                    <tr>
                        <td><code>repriceProductToMax()</code></td>
                        <td>Simplified max price repricing</td>
                        <td>{ cronResponse, priceUpdateResponse }</td>
                    </tr>
                </table>

                <h3>reprice-helper.ts Functions</h3>

                <table>
                    <tr>
                        <th>Function</th>
                        <th>Parameters</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td><code>Reprice()</code></td>
                        <td>refProduct, payload, productItem, sourceId</td>
                        <td>Standard single price break repricing</td>
                    </tr>
                    <tr>
                        <td><code>RepriceIndividualPriceBreak()</code></td>
                        <td>ownProduct, output, productItem, mpid, priceBreak</td>
                        <td>Reprice specific quantity tier</td>
                    </tr>
                    <tr>
                        <td><code>RepriceToMax()</code></td>
                        <td>ownProduct, output, productItem, mpid</td>
                        <td>Set price to maximum configured value</td>
                    </tr>
                    <tr>
                        <td><code>GetDistinctPriceBreaksAcrossVendors()</code></td>
                        <td>output, ownProduct, productItem</td>
                        <td>Find unique quantity tiers across competitors</td>
                    </tr>
                    <tr>
                        <td><code>IsTie()</code></td>
                        <td>sortedPayload, minQty</td>
                        <td>Detect if first two competitors have same price</td>
                    </tr>
                    <tr>
                        <td><code>IsTieWithSister()</code></td>
                        <td>sortedPayload, minQty, productItem</td>
                        <td>Check if tie is with sister vendor</td>
                    </tr>
                    <tr>
                        <td><code>filterEligibleList()</code></td>
                        <td>eligibleList, minQty</td>
                        <td>Remove duplicate price points from competition</td>
                    </tr>
                    <tr>
                        <td><code>isNotShortExpiryProduct()</code></td>
                        <td>priceBreak, allPriceBreaks, minQty</td>
                        <td>Filter out short expiry date products</td>
                    </tr>
                </table>

                <h3>reprice-helper-nc.ts Functions</h3>
                <p>Same function signatures as reprice-helper.ts, with shipping-inclusive logic.</p>

                <table>
                    <tr>
                        <th>Function</th>
                        <th>Key Difference</th>
                    </tr>
                    <tr>
                        <td><code>Reprice()</code></td>
                        <td>Includes shipping in all price comparisons</td>
                    </tr>
                    <tr>
                        <td><code>RepriceIndividualPriceBreak()</code></td>
                        <td>Calculates total cost (price + shipping) per tier</td>
                    </tr>
                    <tr>
                        <td><code>GetShippingPrice()</code></td>
                        <td>Extracts shipping cost from product data</td>
                    </tr>
                </table>

                <h3>repricer-rule-helper.ts Functions</h3>

                <table>
                    <tr>
                        <th>Function</th>
                        <th>Parameters</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td><code>ApplyRule()</code></td>
                        <td>repriceResult, ruleIdentifier, isNcNeeded, net32Details</td>
                        <td>Apply directional pricing rule (Up/Down/Both)</td>
                    </tr>
                    <tr>
                        <td><code>ApplyMultiPriceBreakRule()</code></td>
                        <td>repriceResult</td>
                        <td>Validate price break hierarchy</td>
                    </tr>
                    <tr>
                        <td><code>ApplySuppressPriceBreakRule()</code></td>
                        <td>repriceResult, minQty, isOverrideEnabled</td>
                        <td>Restrict changes to specific quantity tier</td>
                    </tr>
                    <tr>
                        <td><code>ApplyBeatQPriceRule()</code></td>
                        <td>repriceResult</td>
                        <td>Prevent Q1 price changes</td>
                    </tr>
                    <tr>
                        <td><code>ApplyPercentagePriceRule()</code></td>
                        <td>repriceResult, percentage</td>
                        <td>Limit price increase percentage</td>
                    </tr>
                    <tr>
                        <td><code>ApplyDeactivateQPriceBreakRule()</code></td>
                        <td>repriceResult, abortDeactivatingQPriceBreak</td>
                        <td>Prevent automatic quantity tier deactivation</td>
                    </tr>
                    <tr>
                        <td><code>ApplyBuyBoxRule()</code></td>
                        <td>repriceResult, net32Result</td>
                        <td>Protect buy box position</td>
                    </tr>
                    <tr>
                        <td><code>ApplyFloorCheckRule()</code></td>
                        <td>repriceResult, floorPrice</td>
                        <td>Enforce minimum price floor</td>
                    </tr>
                    <tr>
                        <td><code>ApplyRepriceDownBadgeCheckRule()</code></td>
                        <td>repriceResult, result, productItem, badgePercentageDown</td>
                        <td>Badge-specific percentage down logic</td>
                    </tr>
                    <tr>
                        <td><code>ApplyKeepPositionLogic()</code></td>
                        <td>repriceResult, result, ownVendorId</td>
                        <td>Maintain competitive position</td>
                    </tr>
                    <tr>
                        <td><code>ApplySisterComparisonCheck()</code></td>
                        <td>repriceResult, result, productItem</td>
                        <td>Sister vendor validation</td>
                    </tr>
                    <tr>
                        <td><code>AppendNewPriceBreakActivation()</code></td>
                        <td>repriceResult</td>
                        <td>Tag new price break activations</td>
                    </tr>
                    <tr>
                        <td><code>AlignIsRepriced()</code></td>
                        <td>repriceResult</td>
                        <td>Ensure isRepriced flag accuracy</td>
                    </tr>
                    <tr>
                        <td><code>OverrideRepriceResultForExpressCron()</code></td>
                        <td>repriceResult</td>
                        <td>Modify result for express execution mode</td>
                    </tr>
                </table>

                <h3>shared.ts Functions</h3>

                <table>
                    <tr>
                        <th>Function</th>
                        <th>Parameters</th>
                        <th>Returns</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td><code>isPriceUpdateRequired()</code></td>
                        <td>repriceResult, isRepriceOn</td>
                        <td>boolean</td>
                        <td>Determine if price change should execute</td>
                    </tr>
                    <tr>
                        <td><code>getSamePriceBreakDetails()</code></td>
                        <td>outputList, priceBreak, productItem</td>
                        <td>Net32Product[]</td>
                        <td>Get competitors at same quantity tier</td>
                    </tr>
                    <tr>
                        <td><code>notQ2VsQ1()</code></td>
                        <td>minQty, compareWithQ1</td>
                        <td>boolean</td>
                        <td>Check if Q2 vs Q1 comparison applies</td>
                    </tr>
                    <tr>
                        <td><code>getSecretKey()</code></td>
                        <td>cronId, contextVendor</td>
                        <td>Promise&lt;string&gt;</td>
                        <td>Retrieve API secret key from database</td>
                    </tr>
                    <tr>
                        <td><code>isOverrideEnabledForProduct()</code></td>
                        <td>override_bulk_update</td>
                        <td>Promise&lt;boolean&gt;</td>
                        <td>Check if bulk override is globally enabled</td>
                    </tr>
                    <tr>
                        <td><code>MinQtyPricePresent()</code></td>
                        <td>priceBreaks, minQty</td>
                        <td>boolean</td>
                        <td>Check if specific quantity tier exists</td>
                    </tr>
                    <tr>
                        <td><code>getIsFloorReached()</code></td>
                        <td>repricerDetails</td>
                        <td>Promise&lt;boolean&gt;</td>
                        <td>Detect if floor price was hit (#HITFLOOR tag)</td>
                    </tr>
                    <tr>
                        <td><code>getPriceStepValue()</code></td>
                        <td>repricerDetails</td>
                        <td>Promise&lt;string&gt;</td>
                        <td>Calculate $UP, $DOWN, or $SAME indicator</td>
                    </tr>
                </table>
            </section>

            <!-- ========== DATA FLOW ========== -->
            <section id="data-flow">
                <h2>8. Data Flow</h2>

                <h3>Input Data Structure</h3>

                <h4>Net32Product (Competitor Data)</h4>
                <pre><code>interface Net32Product {
    vendorId: number;
    vendorName: string;
    inStock: boolean;
    priceBreaks: Net32PriceBreak[];
    shipping?: {
        standardShipping: number;
        freeShippingThreshold: number;
    };
    handlingTime?: number;
    badgeIndicator?: string;
    inventory?: number;
}</code></pre>

                <h4>Net32PriceBreak (Quantity Tiers)</h4>
                <pre><code>interface Net32PriceBreak {
    minQty: number;        // Quantity threshold (1, 2, 3, 6, 12, etc.)
    unitPrice: number;     // Price per unit at this quantity
    active: boolean;       // Whether this tier is currently active
}</code></pre>

                <h4>FrontierProduct (Internal Configuration)</h4>
                <pre><code>interface FrontierProduct {
    mpid: string;                      // Marketplace Product ID
    productName: string;
    unitPrice: number;                 // Current price

    // Pricing Constraints
    floorPrice: number;                // Minimum allowed price
    maxPrice: number;                  // Maximum allowed price
    percentageDown: number;            // Max % decrease allowed
    percentageIncrease: number;        // Max % increase allowed

    // Repricing Rules
    repricingRule: number;             // 0=Up, 1=Down, 2=Both
    is_nc_needed: boolean;             // Use NC mode (shipping)
    allowReprice: boolean;             // Enable price updates

    // Competition Settings
    competeAll: boolean;               // Compete with all vendors
    competeWithNext: boolean;          // Compete with next when floor reached
    ownVendorId: number;               // Own vendor identifier

    // Multi-Price Settings
    suppressPriceBreak: boolean;       // Single price break mode
    suppressPriceBreakForOne: boolean; // Only update Q1
    compareWithQ1: boolean;            // Q2 competes with Q1
    abortDeactivatingQPriceBreak: boolean;

    // Special Rules
    beatQPrice: boolean;               // Ignore Q1 changes
    applyBuyBoxLogic: boolean;         // Buy box protection
    applyNcForBuyBox: boolean;         // NC override at floor
    getBBShipping: boolean;            // Buy box shipping logic
    getBBBadge: boolean;               // Buy box badge logic
    keepPosition: boolean;             // Maintain competitive rank

    // Filtering
    inventoryThreshold: number;        // Min competitor stock
    badgePercentageDown: number;       // Badge-specific % limit

    // Execution
    cronId: string;                    // Cron job identifier
    cronName: string;                  // Execution context
    contextCronName: string;           // Full execution path
    scrapeOn: boolean;                 // Include scraped data
    algo_execution_mode: AlgoExecutionMode;
    override_bulk_update: boolean;     // Bulk override flag
    override_bulk_rule: number;        // Override rule identifier
}</code></pre>

                <h3>Output Data Structure</h3>

                <h4>RepriceModel (Result)</h4>
                <pre><code>class RepriceModel {
    mpid: string;
    product: Net32Product;
    productName: string;
    isMultiplePriceBreakAvailable: boolean;

    // Single Price Break Result
    repriceDetails?: RepriceData;

    // Multi-Price Break Results
    listOfRepriceDetails: RepriceData[];
}</code></pre>

                <h4>RepriceData (Individual Price Point)</h4>
                <pre><code>interface RepriceData {
    minQty: number;              // Quantity tier
    oldPrice: number;            // Current price
    newPrice: string | number;   // Calculated price ("N/A" if no change)
    goToPrice?: string;          // Rejected price (stored for analysis)
    isRepriced: boolean;         // Will price change execute?
    active: boolean;             // Is this tier active?
    explained: string;           // Reason/message code

    // Metadata
    lowestVendor?: string;       // Who is lowest competitor
    lowestPrice?: number;        // What is lowest price
    triggeredByVendor?: string;  // Who triggered this change
    triggeredByVendorId?: number;
    triggeredByMinQty?: number;
    updatedOn: Date;
}</code></pre>

                <h4>RepriceAsyncResponse (Final Output)</h4>
                <pre><code>class RepriceAsyncResponse {
    repriceData: RepriceModel;      // Calculated pricing decisions
    scrapedData: Net32Product[];    // Competitor data (if scrapeOn=true)
}</code></pre>

                <h3>Data Transformation Flow</h3>

                <div class="flow-diagram">
                    <div class="flow-step"><strong>Input:</strong> Net32Product[] + FrontierProduct</div>
                    <div class="flow-step"><strong>Formatting:</strong> FormatActiveField() + FormatShippingThreshold()</div>
                    <div class="flow-step"><strong>Filtering:</strong> FilterActiveResponse() + GetOwnProduct()</div>
                    <div class="flow-step"><strong>Processing:</strong> Reprice() / RepriceIndividualPriceBreak()</div>
                    <div class="flow-step"><strong>Rule Application:</strong> 15+ rule functions modify RepriceModel</div>
                    <div class="flow-step"><strong>Validation:</strong> isPriceUpdateRequired() check</div>
                    <div class="flow-step"><strong>Execution:</strong> UpdateRequest ‚Üí Vendor API</div>
                    <div class="flow-step"><strong>Output:</strong> RepriceAsyncResponse with results + history ID</div>
                </div>
            </section>

            <!-- ========== EDGE CASES ========== -->
            <section id="edge-cases">
                <h2>9. Edge Cases & Special Scenarios</h2>

                <h3>1. Own Product Not Found in API Response</h3>
                <div class="error-box">
                    <strong>Scenario:</strong> Own vendor not returned by Net32 API<br>
                    <strong>Action:</strong> Return with message <code>IGNORE_NOT_FOUND_API</code><br>
                    <strong>Price Change:</strong> None
                </div>

                <h3>2. Product Out of Stock</h3>
                <div class="warning-box">
                    <strong>Scenario:</strong> <code>ownProduct.inStock === false</code><br>
                    <strong>Action:</strong> Return with message <code>IGNORE_PRODUCT_INACTIVE</code><br>
                    <strong>Price Change:</strong> None
                </div>

                <h3>3. No Active Competitors</h3>
                <div class="success-box">
                    <strong>Scenario:</strong> Only own vendor in eligible list<br>
                    <strong>Action:</strong> Set price to <code>maxPrice</code><br>
                    <strong>Message:</strong> <code>NO_COMPETITOR</code>
                </div>

                <h3>4. Sister Vendor is Lowest</h3>
                <pre><code>if (_.includes(excludedVendors, _.first(sortedPayload).vendorId.toString())) {
    // Sister vendor is lowest - do not compete
    return new RepriceModel(
        sourceId, refProduct, productItem.productName,
        existingPrice, false, false, [],
        NO_COMPETITOR_SISTER_VENDOR
    );
}</code></pre>

                <h3>5. Tie Scenario (Multiple Vendors at Same Price)</h3>
                <pre><code>const isTieScenario = await IsTie(sortedPayload, 1);

if (isTieScenario) {
    const tieWithSister = await IsTieWithSister(sortedPayload, 1, productItem);

    if (!tieWithSister) {
        excludedVendors = [];  // Clear exclusions to compete in tie
    }
}</code></pre>

                <h3>6. Floor Price Reached with Competitor Still Lower</h3>
                <pre><code>if (offsetPrice <= floorPrice) {
    // Verify if sister is already lowest
    const floorSisterResult = await filterMapper.VerifyFloorWithSister(...);

    if (floorSisterResult !== false && allowCompeteWithNextForFloor) {
        // Can't go lower, but sister vendor is handling it
        return floorSisterResult;
    }

    // Hit floor, check if can compete with next vendor
    if (allowCompeteWithNextForFloor && nextLowestPrice > floorPrice) {
        // Compete with next vendor instead of lowest
    }
}</code></pre>

                <h3>7. Multi-Price Break Hierarchy Violation</h3>
                <div class="warning-box">
                    <strong>Example:</strong> Q1=$10, Q2=$12, Q3=$8<br>
                    <strong>Problem:</strong> Q2 > Q1 (invalid)<br>
                    <strong>Action:</strong> <code>ApplyMultiPriceBreakRule()</code> detects and deactivates Q2<br>
                    <strong>Message:</strong> Appends <code>_SHUT_DOWN_FLOOR_REACHED</code>
                </div>

                <h3>8. Price Break with No Competition</h3>
                <pre><code>if (otherVendorRepriceDetails.length === 0 && priceBreak.minQty !== 1) {
    // No competitors at this quantity tier (except Q1 always kept)
    indRepriceResult.togglePricePoint(false);  // Deactivate tier
    indRepriceResult.togglePriceUpdation(true); // Mark for update
}</code></pre>

                <h3>9. Waiting for Next Run State</h3>
                <pre><code>const isWaitingForNextRun = await filterMapper.IsWaitingForNextRun(
    mpid, contextVendor, productItem
);

if (isWaitingForNextRun) {
    // Don't execute price update, but still process and log
    repriceResult = await Rule.OverrideRepriceResultForExpressCron(repriceResult);
    return { cronResponse, priceUpdateResponse: null, historyIdentifier };
}</code></pre>

                <h3>10. API Error During Price Update</h3>
                <pre><code>if (priceUpdatedResponse.data.message.indexOf("ERROR:422") > -1 ||
    priceUpdatedResponse.data.message.indexOf("ERROR:429") > -1 ||
    priceUpdatedResponse.data.message.indexOf("ERROR:404") > -1) {

    // Append failure to explanation
    $.explained = `${$.explained}:FAILED(ERROR:${priceUpdatedResponse.data.message})`;
    $.isRepriced = false;  // Mark as not repriced due to error
}</code></pre>

                <h3>11. Q2 Competing with Q1 Logic</h3>
                <pre><code>if (productItem.compareWithQ1 && !isMinQty2PriceBreakExists) {
    // Add placeholder Q2 tier to compete at Q1 prices
    ownProduct.priceBreaks.push({
        minQty: 2,
        unitPrice: 0,    // Will be calculated
        active: true
    });
}

// Later validation
if (notQ2VsQ1(priceBreak.minQty, productItem.compareWithQ1)) {
    // This is Q2 competing with Q1 - special handling
}</code></pre>

                <h3>12. Override Bulk Update Enabled</h3>
                <pre><code>const isOverrideEnabled = await isOverrideEnabledForProduct(
    productItem.override_bulk_update
);

if (isOverrideEnabled) {
    // Use override rule instead of normal rule
    repriceResult = await Rule.ApplyRule(
        repriceResult,
        productItem.override_bulk_rule,  // Different rule
        isNcToBeApplied,
        ownProduct
    );
}</code></pre>

                <h3>13. NC Buy Box Override at Floor</h3>
                <pre><code>if (productItem.applyNcForBuyBox) {
    for (const $eval of repriceResult.listOfRepriceDetails) {
        const isFloorReached = await getIsFloorReached($eval);

        if (isFloorReached) {
            // Switch to NC mode to potentially win buy box with shipping advantage
            overridingRepriceResult = await repriceHelperNc.RepriceIndividualPriceBreak(...);
            overridingRepriceResult.repriceDetails.explained += " #NCBuyBox";
        }
    }
}</code></pre>

                <h3>14. Inventory Threshold Filtering</h3>
                <pre><code>eligibleList = await filterMapper.FilterBasedOnParams(
    eligibleList,
    productItem,
    "INVENTORY_THRESHOLD"
);

// Removes competitors with inventory below configured threshold
// Prevents competing with vendors who can't fulfill orders</code></pre>

                <h3>15. Handling Time Filter</h3>
                <pre><code>eligibleList = await filterMapper.FilterBasedOnParams(
    eligibleList,
    productItem,
    "HANDLING_TIME"
);

// Excludes competitors with slow handling times
// Focuses competition on vendors with similar service levels</code></pre>
            </section>

            <!-- ========== INTEGRATION ========== -->
            <section id="integration">
                <h2>10. Integration Points</h2>

                <h3>External Dependencies</h3>

                <h4>1. Net32 API (Competitor Data Source)</h4>
                <ul>
                    <li><strong>Purpose:</strong> Provides competitive pricing data</li>
                    <li><strong>Data:</strong> Vendor prices, stock status, shipping, badges</li>
                    <li><strong>Format:</strong> <code>Net32Product[]</code> array</li>
                    <li><strong>Error Handling:</strong> Empty response throws error immediately</li>
                </ul>

                <h4>2. Vendor Price Update APIs</h4>
                <pre><code>const priceUpdateUrl = apiMapping.find(
    x => x.vendor === contextVendor.toUpperCase()
)?.priceUpdateUrl;

const priceUpdatedResponse = await axiosHelper.postAsync(
    priceUpdatedRequest,
    priceUpdateUrl
);</code></pre>
                <ul>
                    <li><strong>Vendors:</strong> NET32, DARBY, etc.</li>
                    <li><strong>Payload:</strong> <code>UpdateRequest</code> with mpid, price, secret key</li>
                    <li><strong>Response:</strong> Success/failure status with error codes</li>
                </ul>

                <h4>3. MongoDB (Configuration & History)</h4>
                <pre><code>// Configuration retrieval
const cronSettingDetails = await dbHelper.GetCronSettingsDetailsById(cronId);
const globalConfig = await dbHelper.GetGlobalConfig();

// History recording
const historyIdentifier = await HistoryHelper.Execute(
    mpid, repriceResult, output, isNcToBeApplied, contextVendor, contextCronName
);</code></pre>
                <ul>
                    <li><strong>Collections:</strong> CronSettings, GlobalConfig, History</li>
                    <li><strong>Operations:</strong> Read settings, write history, update status</li>
                </ul>

                <h4>4. MySQL (Status & Tracking)</h4>
                <pre><code>// Update triggered vendor
await mySqlHelper.UpdateTriggeredByVendor(repriceResult, contextVendor, mpid);

// Update reprice result status
await mySqlHelper.UpdateRepriceResultStatus(repriceResultStatus, mpid, contextVendor);</code></pre>
                <ul>
                    <li><strong>Tables:</strong> RepriceStatus, TriggeredVendor</li>
                    <li><strong>Operations:</strong> Status updates, vendor tracking</li>
                </ul>

                <h3>Internal Module Dependencies</h3>

                <h4>format-wrapper</h4>
                <ul>
                    <li><code>FormatActiveField()</code> - Normalize boolean active flags</li>
                    <li><code>FormatShippingThreshold()</code> - Parse shipping data</li>
                    <li><code>SetGlobalDetails()</code> - Apply global vendor config</li>
                    <li><code>SetOwnVendorThreshold()</code> - Apply threshold filtering</li>
                </ul>

                <h4>response-utility</h4>
                <ul>
                    <li><code>GetOwnProduct()</code> - Extract own vendor from results</li>
                    <li><code>FilterActiveResponse()</code> - Filter to active products</li>
                </ul>

                <h4>filter-mapper</h4>
                <ul>
                    <li><code>FilterBasedOnParams()</code> - Generic filtering engine</li>
                    <li><code>GetContextPrice()</code> - Calculate price with offset</li>
                    <li><code>IsVendorFloorPrice()</code> - Check if vendor at floor</li>
                    <li><code>VerifyFloorWithSister()</code> - Sister vendor floor logic</li>
                    <li><code>AppendPriceFactorTag()</code> - Add pricing factor tags</li>
                    <li><code>IsWaitingForNextRun()</code> - Check execution state</li>
                </ul>

                <h4>badge-helper</h4>
                <ul>
                    <li>Badge presence detection</li>
                    <li>Badge-specific pricing logic</li>
                </ul>

                <h4>buy-box-helper</h4>
                <ul>
                    <li><code>parseShippingBuyBox()</code> - Shipping buy box strategy</li>
                    <li><code>parseBadgeBuyBox()</code> - Badge buy box strategy</li>
                </ul>

                <h4>repriceResultParser</h4>
                <ul>
                    <li><code>Parse()</code> - Convert RepriceModel to status code</li>
                </ul>

                <h3>Data Flow Diagram</h3>

                <div class="flow-diagram">
                    <div class="flow-step"><strong>1. API Layer</strong> ‚Üí receives request with mpid + vendor context</div>
                    <div class="flow-step"><strong>2. Net32 API</strong> ‚Üí fetches competitor data</div>
                    <div class="flow-step"><strong>3. MongoDB</strong> ‚Üí retrieves product configuration</div>
                    <div class="flow-step"><strong>4. algo-v1.repriceProduct()</strong> ‚Üí main orchestration</div>
                    <div class="flow-step"><strong>5. reprice-helper</strong> ‚Üí calculates optimal price</div>
                    <div class="flow-step"><strong>6. repricer-rule-helper</strong> ‚Üí applies business rules</div>
                    <div class="flow-step"><strong>7. MongoDB</strong> ‚Üí writes history record</div>
                    <div class="flow-step"><strong>8. MySQL</strong> ‚Üí updates status tables</div>
                    <div class="flow-step"><strong>9. Vendor API</strong> ‚Üí executes price update (if needed)</div>
                    <div class="flow-step"><strong>10. Response</strong> ‚Üí returns comprehensive result</div>
                </div>

                <h3>Configuration Sources</h3>

                <table>
                    <tr>
                        <th>Setting</th>
                        <th>Source</th>
                        <th>Used By</th>
                    </tr>
                    <tr>
                        <td>FLAG_MULTI_PRICE_UPDATE</td>
                        <td>applicationConfig</td>
                        <td>algo-v1 (enable multi-price logic)</td>
                    </tr>
                    <tr>
                        <td>OFFSET</td>
                        <td>applicationConfig</td>
                        <td>reprice-helper (undercut amount)</td>
                    </tr>
                    <tr>
                        <td>IS_DEV</td>
                        <td>applicationConfig</td>
                        <td>algo-v1 (skip actual API calls)</td>
                    </tr>
                    <tr>
                        <td>VENDOR_ID</td>
                        <td>globalParam.GetInfo()</td>
                        <td>All helpers (own vendor identification)</td>
                    </tr>
                    <tr>
                        <td>EXCLUDED_VENDOR_ID</td>
                        <td>globalParam.GetInfo()</td>
                        <td>reprice-helper (sister vendor filtering)</td>
                    </tr>
                    <tr>
                        <td>SecretKey</td>
                        <td>MongoDB CronSettings</td>
                        <td>algo-v1 (API authentication)</td>
                    </tr>
                    <tr>
                        <td>override_all</td>
                        <td>MongoDB GlobalConfig</td>
                        <td>shared (bulk override flag)</td>
                    </tr>
                </table>

                <h3>Execution Modes</h3>

                <pre><code>enum AlgoExecutionMode {
    V1_ONLY = "V1_ONLY",                   // Execute V1, update prices
    V1_EXECUTE_V2_DRY = "V1_EXECUTE_V2_DRY", // Execute V1, update prices, log V2
    V2_ONLY = "V2_ONLY",                   // Execute V2 only (not V1)
    V2_EXECUTE_V1_DRY = "V2_EXECUTE_V1_DRY"  // Execute V2, update prices, log V1
}

// Only update prices if V1 is executing mode
const priceChangeAllowed =
    productItem.algo_execution_mode === AlgoExecutionMode.V1_ONLY ||
    productItem.algo_execution_mode === AlgoExecutionMode.V1_EXECUTE_V2_DRY;</code></pre>
            </section>

            <!-- Footer -->
            <footer style="margin-top: 60px; padding-top: 20px; border-top: 2px solid #ecf0f1; color: #7f8c8d; text-align: center;">
                <p>V1 Repricing Algorithm Documentation</p>
                <p>Generated: <script>document.write(new Date().toLocaleDateString())</script></p>
                <p style="font-size: 0.9rem;">Total Algorithm Size: 5,103 lines across 5 files</p>
            </footer>
        </main>
    </div>
</body>
</html>